/-
Copyright (c) 2020 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Simon Hudon
-/
import data.finmap
import data.multiset.sort
import tactic.find_unused
import tactic.abel
import testing.slim_check.sampleable
import testing.slim_check.testable

/-!
## `slim_check`: generators for functions

This file defines `sampleable` instances for `ℤ → ℤ` functions and
`ℤ → ℤ` injective functions.

Functions are generated by creating a list of pairs and one more value
using the list as a lookup table and resorting to the additional value
when a value is not found in the table.

Injective functions are generated by creating a list of numbers and
a permutation of that list. The permutation insures that every input
is mapped to a unique output. When an input is not found in the list
the input itself is used as an output.
-/

universes u v w

namespace slim_check

/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`with_default f y` encodes `x ↦ f x` when `x ∈ f` and `x ↦ y`
otherwise.
 -/
inductive total_function (α : Type u) (β : Type v) : Type (max u v)
| with_default : list (Σ _ : α, β) → β → total_function

instance total_function.inhabited {α β} [inhabited β] : inhabited (total_function α β) :=
⟨ total_function.with_default ∅ (default _) ⟩

namespace total_function

/-- Apply a total function to an argument. -/
def apply {α β : Type*} [decidable_eq α] : total_function α β → α → β
| (total_function.with_default m y) x := (m.lookup x).get_or_else y

/--
Implementation of `has_repr (total_function α β)`.

Creates a string for a given `finmap` and output, `x₀ ↦ y₀, .. xₙ ↦ yₙ`
for each of the entries. The brackets are provided by the calling function.
-/
def repr_aux {α : Type u} [has_repr α] {β : Type v} [has_repr β] (m : list (Σ _ : α, β)) : string :=
string.join $ list.qsort (λ x y, x < y) (m.map $ λ x, sformat!"{repr $ sigma.fst x} ↦ {repr $ sigma.snd x}, ")

/--
Produce a string for a given `total_function`.

For `with_default f y`, produce `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, _ ↦ y]`.

For `map_to_self f`, produce `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.
-/
protected def repr {α : Type u} [has_repr α] {β : Type v} [has_repr β] : total_function α β → string
| (total_function.with_default m y) := sformat!"[{repr_aux m}_ ↦ {has_repr.repr y}]"

instance (α : Type u) (β : Type v) [has_repr α] [has_repr β] : has_repr (total_function α β) :=
⟨ total_function.repr ⟩

/-- Convert a product type to a Σ-type. -/
@[simp]
def prod.to_sigma {α β} : α × β → Σ _ : α, β
| ⟨x,y⟩ := ⟨x,y⟩

/-- Convert a product type to a Σ-type. -/
@[simp]
def sigma.to_prod {α β} : (Σ _ : α, β) → α × β
| ⟨x,y⟩ := ⟨x,y⟩

/-- Create a `finmap` from a list of pairs. -/
def list.to_finmap' {α β} [decidable_eq α] (xs : list (α × β)) : list (Σ _ : α, β) :=
xs.map prod.to_sigma

@[simp]
lemma prod.fst_to_sigma {α β} (x : α × β) : (prod.to_sigma x).fst = x.fst :=
by cases x; refl

instance ulift.has_repr {α} [has_repr α] : has_repr (ulift α) :=
⟨ λ ⟨x⟩, repr x ⟩

section

variables {α : Type u} {β : Type v} [sampleable α] [sampleable β]

def total.sizeof : total_function α β → ℕ
| ⟨m, x⟩ := 1 + @sizeof _ sampleable.wf m + sizeof x

@[priority 2000]
instance : has_sizeof (total_function α β) :=
⟨ total.sizeof ⟩

variables [decidable_eq α]

lemma sizeof_kerase {α β} [decidable_eq α] [has_sizeof (Σ _ : α, β)] (x : α) (xs : list (Σ _ : α, β)) :
  sizeof (list.kerase x xs) ≤ sizeof xs :=
begin
  unfold_wf,
  induction xs with y ys,
  { simp },
  { by_cases x = y.1; simp [*, list.sizeof] },
end

lemma sizeof_erase_dupkeys {α β} [decidable_eq α] [has_sizeof (Σ _ : α, β)] (xs : list (Σ _ : α, β)) :
  sizeof (list.erase_dupkeys xs) ≤ sizeof xs :=
begin
  unfold_wf,
  induction xs with x xs,
  { simp [list.erase_dupkeys] },
  { simp [list.erase_dupkeys_cons, list.sizeof],
    transitivity, apply sizeof_kerase,
    assumption }
end

protected def shrink : shrink_fn (total_function α β)
| ⟨m, x⟩ := (sampleable.shrink (m, x)).map $ λ ⟨⟨m', x'⟩, h⟩, ⟨⟨list.erase_dupkeys m', x'⟩,
            lt_of_le_of_lt (by unfold_wf; refine @sizeof_erase_dupkeys _ _ _ (@sampleable.wf _ _) _) h ⟩

variables
 [has_repr α] [has_repr β]

instance pi.sampleable_ext : sampleable_ext (α → β) :=
{ proxy_repr := total_function α β,
  interp := total_function.apply,
  sample := do {
    xs ← (sampleable.sample (list (α × β)) : gen ((list (α × β)))),
    ⟨x⟩ ← (uliftable.up $ sample β : gen (ulift.{(max u v)} β)),
    pure $ total_function.with_default (list.to_finmap' xs) x },
  shrink := total_function.shrink }

end

section sampleable_ext
open sampleable_ext

@[priority 2000]
instance pi_pred.sampleable_ext {α : Type u} [sampleable_ext (α → bool)] : sampleable_ext.{u+1} (α → Prop) :=
{ proxy_repr := proxy_repr (α → bool),
  interp := λ m x, interp (α → bool) m x,
  sample := sample (α → bool),
  shrink := shrink }

@[priority 2000]
instance pi_uncurry.sampleable_ext {α : Type u} {β : Type v} {γ : Sort w} [sampleable_ext (α × β → γ)] : sampleable_ext.{(imax (u+1) (v+1) w)} (α → β → γ) :=
{ proxy_repr := proxy_repr (α × β → γ),
  interp := λ m x y, interp (α × β → γ) m (x, y),
  sample := sample (α × β → γ),
  shrink := shrink }

end sampleable_ext

end total_function

/--
Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`map_to_self f` encodes `x ↦ f x` when `x ∈ f` and `x ↦ x`,
i.e. `x` to itself, otherwise.
-/
inductive injective_function (α : Type u) : Type u
| map_to_self : list (Σ _ : α, α) → injective_function

namespace injective_function

/-- Apply a total function to an argument. -/
def apply {α : Type u} [decidable_eq α] : injective_function α → α → α
| (injective_function.map_to_self m) x := (m.lookup x).get_or_else x

protected def repr {α : Type u} [has_repr α] : injective_function α → string
| (injective_function.map_to_self m) := sformat!"[{total_function.repr_aux m}x ↦ x]"

instance (α : Type u) [has_repr α] : has_repr (injective_function α) :=
⟨ injective_function.repr ⟩

open total_function (prod.to_sigma sigma.to_prod)

/-- Interpret a list of pairs as a total function, defaulting to
the identity function when no entries are found for a given function -/
def list.apply_id {α : Type u} [decidable_eq α] (xs : list (α × α)) (x : α) : α :=
((xs.map prod.to_sigma).lookup x).get_or_else x

@[simp]
lemma list.apply_id_cons {α : Type u} [decidable_eq α] (xs : list (α × α)) (x y z : α) :
  list.apply_id ((y, z) :: xs) x = if y = x then z else list.apply_id xs x :=
by simp [list.apply_id, list.lookup]; split_ifs; refl

open function list prod
open nat

lemma nth_injective {α : Type u} {xs : list α} (i j : ℕ) (a : α)
  (h : nodup xs)
  (hi : xs.nth i = some a)
  (hj : xs.nth j = some a) : i = j :=
begin
  induction xs with x xs generalizing i j,
  { cases hj },
  { wlog : i ≤ j,
    cases h with _ _ h₀ h₁,
    cases j,
    { cases case, refl },
    cases i,
    { specialize h₀ a _,
      { injection hi, contradiction },
      { rw mem_iff_nth, exact ⟨_, hj⟩ } },
    { congr, apply xs_ih; assumption, } }
end

lemma foo {α : Type u} [decidable_eq α] {xs ys : list α} (h₀ : list.nodup xs)
  (h₁ : xs.length = ys.length) (x y : α) (i : ℕ)
  (h₂ : xs.nth i = some x) :
  ys.nth i = some y ↔ list.apply_id.{u} (xs.zip ys) x = y :=
begin
  induction xs generalizing ys i,
  { cases h₂ },
  { cases i,
    injection h₂; subst h_1,
    cases ys,
    { cases h₁ },
    { simp [list.apply_id], },
    cases ys,
    { cases h₁ },
    { cases h₀,
      simp at h₂ ⊢, rw if_neg,
      apply xs_ih; solve_by_elim [succ.inj],
      apply h₀_a_1,
      apply nth_mem h₂ } }
end

lemma bar {α : Type u} {xs ys : list α} (h₀ : list.nodup xs)
  (h₁ : xs ~ ys) (i j : ℕ) :
  xs.nth i = xs.nth j ↔ ys.nth i = ys.nth j :=
begin
  revert xs ys,
  suffices : ∀ {xs ys : list α}, xs.nodup → xs ~ ys → (xs.nth i = xs.nth j → ys.nth i = ys.nth j),
  { intros,
    have h₂ : ys.nodup := h₁.nodup_iff.1 h₀,
    have h₃ := h₁.symm,
    split; apply this; assumption, },
  introv h₀ h₁ h₂,
  by_cases j < xs.length,
  { congr, rw nth_le_nth h at h₂,
    apply nth_injective _ _ _ h₀ h₂,
    rw nth_le_nth },
  { have h' : ¬j < ys.length, { rwa ← h₁.length_eq },
    rw nth_len_le (le_of_not_gt h) at h₂,
    rw nth_len_le (le_of_not_gt h'),
    rw nth_eq_none_iff at h₂ ⊢,
    rwa ← h₁.length_eq, }
end

lemma foo_bar {α : Type u} [decidable_eq α] {xs ys : list α} (h₀ : list.nodup xs)
  (h₁ : xs ~ ys)
  (x : α) :
  x ∈ xs ↔ list.apply_id.{u} (xs.zip ys) x ∈ ys :=
begin
  simp [list.apply_id],
  cases h₃ : (lookup x (map prod.to_sigma (xs.zip ys))),
  { dsimp [option.get_or_else],
    rw h₁.mem_iff },
  { have h₂ : ys.nodup := h₁.nodup_iff.1 h₀,
    replace h₁ : xs.length = ys.length := h₁.length_eq,
    dsimp,
    induction xs with x' xs generalizing ys,
    { contradiction },
    { cases ys with y ys, cases h₃,
      dsimp [lookup] at h₃, split_ifs at h₃,
      { subst x', subst val, simp },
      { cases h₀ with _ _ h₀ h₅,
        cases h₂ with _ _ h₂ h₄,
        have h₆ := nat.succ.inj h₁,
        specialize @xs_ih h₅ ys h₃ h₄ h₆,
        simp [ne.symm h, xs_ih],
        suffices : val ∈ ys, tauto!,
        erw [← option.mem_def, mem_lookup_iff] at h₃,
        simp at h₃,
        rcases h₃ with ⟨a, b, h₃, h₄, h₅⟩,
        subst a, subst b,
        apply (mem_zip h₃).2,
        simp [nodupkeys, keys, (∘), map_fst_zip],
        rwa map_fst_zip _ _ (le_of_eq h₆) } } }
end

lemma bar_foo {α : Type u} [decidable_eq α] {xs ys : list α} (x : α) :
  x ∉ xs → list.apply_id.{u} (xs.zip ys) x = x :=
begin
  intro h,
  dsimp [list.apply_id],
  rw lookup_eq_none.2, refl,
  simp [keys],
  intros y hy,
  exact h (mem_zip hy).1,
end

lemma apply_id_injective {α : Type u} [decidable_eq α] {xs ys : list α} (h₀ : list.nodup xs) (h₁ : xs ~ ys) :
  injective.{u+1 u+1}
    (list.apply_id (xs.zip ys))
:=
begin
  intros x y h,
  by_cases hx : x ∈ xs;
    by_cases hy : y ∈ xs,
  { rw mem_iff_nth at hx hy,
    cases hx with i hx,
    cases hy with j hy,
    suffices : some x = some y,
    { injection this },
    have h₂ := h₁.length_eq,
    rw [← foo h₀ h₂ _ _ _ hx] at h,
    rw [← hx, ← hy, bar h₀ h₁, h],
    symmetry,
    rw foo; assumption, },
  { rw foo_bar h₀ h₁ at hx hy,
    rw h at hx,
    contradiction, },
  { rw foo_bar h₀ h₁ at hx hy,
    rw h at hx,
    contradiction, },
  { rwa [bar_foo, bar_foo] at h; assumption },
end

open total_function (list.to_finmap')

lemma interp_injective {α : Type u} [decidable_eq α] {xs ys : list α} (h₀ : list.nodup xs) (h₁ : xs ~ ys) :
  injective.{u+1 u+1}
    (apply (injective_function.map_to_self (list.to_finmap'.{u u} $ xs.zip ys))) :=
begin
  simp [list.to_finmap'],
  intros x y h,
  dsimp [apply] at h,
  replace h : list.apply_id.{u} (xs.zip ys) x = list.apply_id (xs.zip ys) y := h,
  refine (apply_id_injective h₀ h₁ h),
end

open sampleable

#eval list.diff [1,1,2,2] [1]

lemma filter_eq {α} (p q : α → Prop) [decidable_pred p] [decidable_pred q] (l : list α)
  (h : ∀ x ∈ l, p x ↔ q x) :
  filter p l = filter q l :=
begin
  induction l; simp [filter],
  have : (∀ (x : α), x ∈ l_tl → (p x ↔ q x)),
  { introv h', apply h _ (or.inr h') },
  congr' 1; simp [h, l_ih this],
end

-- #check perm.take

lemma perm.take_inter {α} [decidable_eq α] {xs ys : list α} (n : ℕ)
  (h : xs ~ ys) (h' : ys.nodup) :
  xs.take n ~ ys.inter (xs.take n) :=
begin
  simp [list.inter] at *,
  induction h generalizing n,
  case list.perm.nil
  { simp [list.inter], },
  case list.perm.cons
  { cases n; simp [list.inter, take],
    cases h' with h₁ h₂,
    convert h_ih h'_a_1 n using 1,
    apply filter_eq,
    introv h, simp [(h'_a _ h).symm] },
  case list.perm.swap
  { rcases h' with ⟨_, _, h₁, h₂⟩,
    rcases h'_a_2 with ⟨_, _, h₁, h₂⟩,
    have := h'_a_1 _ (or.inl rfl),
    cases n; simp,
    cases n; simp [filter, *],
    { rw filter_eq_nil.2, intros, solve_by_elim [ne.symm], },
    { convert perm.swap _ _ _, rw filter_eq _ (∈ take n h_l),
      { clear h'_a_1, induction n generalizing h_l; simp,
        cases h_l; simp, cases h'_a_2_a_2,
        rwa [filter_eq _ (∈ take n_n h_l_tl), n_ih],
        { introv h, apply h'_a_2_a_1 _ (or.inr h), },
        { introv h, simp [(h'_a_2_a_2_a_1 _ h).symm], }, },
      { introv h, simp [(h'_a_2_a_1 _ h).symm, (h'_a_1 _ (or.inr h)).symm], } } },
  case list.perm.trans
  { transitivity,
    { apply h_ih_a, rwa h_a_1.nodup_iff },
    { apply perm.filter _ h_a_1, } },
end

lemma reverse_take {α} {xs : list α} (n : ℕ)
  (h : n ≤ xs.length) :
  xs.reverse.take n = (xs.drop (xs.length - n)).reverse :=
begin
  induction xs generalizing n; simp,
  cases decidable.lt_or_eq_of_le h with h' h',
  { replace h' := le_of_succ_le_succ h',
    rwa [take_append_of_le_length, xs_ih _ h'],
    rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n), from _, drop],
    { rwa [succ_eq_add_one, nat.sub_add_comm] },
    { rwa length_reverse } },
  { subst h', rw [length, nat.sub_self, drop],
    rw [show xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length, from _, take_length, reverse_cons],
    rw [length_append, length_reverse], refl }
end

lemma perm.drop_inter {α} [decidable_eq α] {xs ys : list α} (n : ℕ)
  (h : xs ~ ys) (h' : ys.nodup) :
  xs.drop n ~ ys.inter (xs.drop n) :=
begin
  by_cases h'' : n ≤ xs.length,
  { let n' := xs.length - n,
    have h₀ : n = xs.length - n',
    { dsimp [n'], rwa nat.sub_sub_self, } ,
    have h₁ : n' ≤ xs.length, sorry,
    have h₂ : xs.drop n = (xs.reverse.take n').reverse,
    { rw [reverse_take _ h₁, h₀, reverse_reverse], },
    rw [h₂],
    apply (reverse_perm _).trans,
    convert (perm.take_inter _ h _) using 1,
    apply perm.filter,
    apply (reverse_perm _).trans; assumption,
    simp [n', nat.sub_le], },
  { have : drop n xs = [],
    { apply eq_nil_of_length_eq_zero,
      rw [length_drop, nat.sub_eq_zero_iff_le],
      apply le_of_not_ge h'' },
    simp [this, list.inter], }
end

def perm.take {α} [decidable_eq α] (n : ℕ) : (Σ' xs ys : list α, xs ~ ys ∧ ys.nodup) → (Σ' xs ys : list α, xs ~ ys ∧ ys.nodup)
| ⟨xs, ys, h, h'⟩ :=
  let xs₀ := xs.take n in
  have h₀ : xs₀ ~ ys.inter xs₀,
    from perm.take_inter _ h h',
  ⟨xs₀, ys.inter xs₀, h₀, nodup_inter_of_nodup _ h'⟩

-- #check list.slice .

def list.slice {α} : ℕ → ℕ → list α → list α
| 0 n xs := xs.drop n
| (succ n) m [] := []
| (succ n) m (x :: xs) := x :: list.slice n m xs

lemma perm.take_slice {α} [decidable_eq α] {xs ys : list α} (n m : ℕ)
  (h : xs ~ ys) (h' : ys.nodup) :
  list.slice n m xs ~ ys.inter (list.slice n m xs) :=
begin
  simp [list.inter] at *,
  induction h generalizing n,

end

def perm.slice {α} [decidable_eq α] (n m : ℕ) : (Σ' xs ys : list α, xs ~ ys ∧ ys.nodup) → (Σ' xs ys : list α, xs ~ ys ∧ ys.nodup)
| ⟨xs, ys, h, h'⟩ :=
  let xs' := list.slice n m xs in
  have h₀ : xs' ~ ys.inter xs',
    from perm.take_slice _ _ h h',
  ⟨xs', ys.inter xs', h₀, nodup_inter_of_nodup _ h'⟩

def perm.drop {α} [decidable_eq α] (n : ℕ) : (Σ' xs ys : list α, xs ~ ys) → (Σ' xs ys : list α, xs ~ ys)
| ⟨xs, ys, h⟩ :=
  let xs' := xs.split_at n,
      xs₀ := xs'.1,
      xs₁ := xs'.2 in
  have h₁ : xs₁ ~ ys.diff xs₀,
    begin
      simp [xs', xs₀, xs₁] at *, clear xs₀ xs₁ xs',
    end,
  ⟨xs₁, ys.diff xs₀, h₁⟩

def perm.split_at {α} [decidable_eq α] (n : ℕ) : (Σ' xs ys : list α, xs ~ ys) → (Σ' xs ys : list α, xs ~ ys) × (Σ' xs ys : list α, xs ~ ys)
| ⟨xs, ys, h⟩ :=
  let xs' := xs.split_at n,
      xs₀ := xs'.1,
      xs₁ := xs'.2 in
  -- have h₂ : xs₀.subset ys, from _,
  have h₂ : ys.nodup, from _,
  have h₀ : xs₀ ~ ys.diff xs₁,
    begin
      simp [xs', xs₀, xs₁] at *, clear xs₀ xs₁ xs',
      induction xs generalizing n ys,
      { rw ← perm.nil_eq h, simp },
      { cases n,
        { simp only [take, drop],
          symmetry, rw [perm_nil, diff_eq_filter_of_nodup h₂, filter_eq_nil],
          intros a h₀ h₁, apply h₁,
          apply @perm.subset _ _ _ h.symm _ h₀ },
        { simp only [take, drop],
          cases ys with y ys, rw perm_nil at h, cases h,
          rw [diff_eq_filter_of_nodup h₂, filter], split_ifs,
          {  },
 }
 },
    end,
  have h₁ : xs₁ ~ ys.diff xs₀, from _,
  (⟨xs₀, ys.diff xs₁, h₀⟩, ⟨xs₁, ys.diff xs₀, h₁⟩)

protected def shrink_perm {α} [decidable_eq α] : shrink_fn (Σ' xs ys : list α, xs ~ ys)
| ⟨xs,ys,h⟩ := do
  let n := xs.length,
  let ⟨xs₀, xs⟩ := xs.split_at (n / 3),
  let ⟨xs₁, xs₂⟩ := xs.split_at (n / 3),
  ⟨xa₀, xb₀⟩ ← lazy_list.of_list [ ([], xs₀), (xs₀, []) ],
  ⟨xa₁, xb₁⟩ ← lazy_list.of_list [ ([], xs₁), (xs₁, []) ],
  ⟨xa₂, xb₂⟩ ← lazy_list.of_list [ ([], xs₂), (xs₂, []) ],
  let ys' := ys.diff (xb₀ ++ xb₁ ++ xb₂),
  let ys'' := ys'.split_at (ys'.length / 2),
  have hs : xa₀ ++ xa₁ ++ xa₂ ~ ys', from sorry,
  have hs' : xa₀ ++ xa₁ ++ xa₂ ~ ys''.2 ++ ys''.1, from sorry,
  lazy_list.of_list [ ⟨⟨xa₀ ++ xa₁ ++ xa₂, ys', hs⟩, _⟩, ⟨⟨xa₀ ++ xa₁ ++ xa₂, ys''.2 ++ ys''.1, hs'⟩, _⟩ ],
  _



protected def shrink {α} [sampleable α] : shrink_fn (injective_function α)
| ⟨m⟩ := (sampleable.shrink m).map $ λ ⟨m', h⟩, ⟨⟨_⟩, _⟩

instance pi_injective.sampleable_ext : sampleable_ext { f : ℤ → ℤ // function.injective f } :=
{ proxy_repr := { f : injective_function ℤ // function.injective (apply f) },
  interp := subtype.map apply $ λ x h, h,
  sample := gen.sized $ λ sz, do {
    let xs' := int.range (-(2*sz+2)) (2*sz + 2),
    ys ← gen.permutation_of xs',
    let r : injective_function ℤ := injective_function.map_to_self (list.to_finmap' (xs'.zip ys.1)),
    have Hinj : injective (λ (r : ℕ), -(2*sz + 2 : ℤ) + ↑r), from λ x y h, int.coe_nat_inj (add_right_injective _ h),
    pure ⟨r, interp_injective (list.nodup_map Hinj (nodup_range _)) ys.2⟩ },
  shrink := λ _, lazy_list.nil }

end injective_function

open function

instance injective.testable {α β} (f : α → β)
  [I : testable (named_binder "x" $ ∀ x : α, named_binder "y" $ ∀ y : α, named_binder "H" $ f x = f y → x = y)] :
  testable (injective f) := I

instance monotone.testable {α β} [preorder α] [preorder β] (f : α → β)
  [I : testable (named_binder "x" $ ∀ x : α, named_binder "y" $ ∀ y : α, named_binder "H" $ x ≤ y → f x ≤ f y)] :
  testable (monotone f) := I

end slim_check
